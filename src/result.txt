NOTES: 
The CAP Theorem was first postulated by Dr. Eric Brewer back in the year 2000. This theorem describes the behavior of a distributed system, and here the definition of a distributed system is pretty specific. It’s a collection of interconnected nodes that all share data. A client can write data to a distributed system by talking to any one of these nodes, and then the client can read data from the distributed system by talking to either that same node or a different node. This theorem talks about how the system reacts when it gets a write request followed by a read request. The theorem states that for any given pair of requests, a write followed by a read, a distributed system can promise to guarantee only two out of three attributes. These attributes are consistency, availability, and partition tolerance. You can get any two at any given time, but you cannot have all three.
NOTES: 

NOTES: 

NOTES: 
Durability is the promise that we handle a message once and only once. We can break durability down into three guarantees.
NOTES: 
ed specifically to solve the problems that arise with distributed systems. What’s unique about an append-only model is that you can never update or delete the data. You can only insert. You just need to append new data to the end.
NOTES: 
Consistency means that the system guarantees to read data that is at least as fresh as what you just wrote. So, whether the client reads from the same node that I just wrote to or from a different node, that node is not allowed to return stale data
NOTES: 
Availability means that a non-failing node will give the client a reasonable response within a reasonable amount of time. Now, all that’s relative, but what that really means is that it won’t hang indefinitely, and it won’t return an error.
NOTES: 
Partition tolerance guarantees that a distributed system will continue to function in the face of network partitions. A network partition is a breaking connectivity. It means that nodes within the system cannot communicate with one another.
NOTES: 
So, those are really your only two choices, forfeit consistency for availability or forfeit availability for consistency. You cannot consciously choose to give up partition tolerance because it’s a fallacy to believe that the network is reliable. Network partitions are going to happen, and when they do your software will either be inconsistent or unavailable.
NOTES: 
The next task in a DDD project is to carve the domain into bounded contexts. The term bounded context refers to the circumstances in which certain words of the ubiquitous language have certain meanings. Each context uses a particular dialect of the ubiquitous language, and each one is optimized to solve a specific problem.
NOTES: 
Each bounded context is a separate solution. It’s very likely that a different development team is going to be working on each individual bounded context even if it doesn’t start out that way.,Within each solution the projects are organized into layers. Eric Evans talks about four layers in his book, and we have three of them represented here. These are Domain, Application, and Presentation. The Domain layer contains the model. It has all of the entities and value objects of the problem domain. All of these objects are expressed in terms of the ubiquitous language. A business owner looking at this model will be able to verify whether it’s accurate or not. Above the Domain layer we have the Application layer. This layer contains all of the business services. These are the behaviors that don’t necessarily belong to a specific entity. For example, PerformanceCalculator is a service that creates ReportCard entities. It would be inappropriate to make this a responsibility of the ReportCard itself because that’s the product of this factory, so this service, PerformanceCalculator, is separated from the Domain and moved up into the Application layer. At the top above the application layer we have the Presentation layer. This exposes all of the services and domain objects to the outside users. The Presentation for some bounded context is a user interface.
NOTES: 
Finally, an aggregate root is the top-level entity of an aggregate of children and grandchildren. Business operations are performed on the aggregate as a whole and not on the individual objects within it. The root is the only entity within the aggregate that has global identity, and other aggregates cannot reference any of its children directly. And the root controls how an aggregate is queried, altered, and deleted.
NOTES: 
It says that a method should either change the state of an object or return a result, but not both. Methods that change state are called commands, and methods that return results are called queries. . From the outside it’s pretty easy to tell which is which. A query will declare a return type, and a command will return void. The problem that Command Query Responsibility Segregation is really good at solving is a problem of blocking the user when locking the data.,For the most part we really don’t want to apply CQRS in a lot of situations. The only place where it makes sense is in these collaborative domains whenever we have a large number of people all working together on a small set of data. That’s when CQRS can kind of bring order to the chaos.
NOTES: 
et’s start a second instance of the consumer, and you’ll see that it process just a few orders successfully, but then we get an exception in the service. If we drill into this exception, we’ll see that this is a deadlock. This occurred because two of our clients were trying to update the same inventory record at the same time. So, they both took a read lock on the record to get the current inventory, and then tried to escalate to a write lock in order to update it. Now, you can’t escalate to a write lock while another reader still holds the record, and neither one of these readers is going to give it up, so the database is going to choose a deadlock victim and kill it.  We need to be able to take the order without processing it, and then we need to be able to process it later. And when the customer needs to check the status of the order, they can call back. And that’s the first step toward Command Query Responsibility Segregation. It won’t get us all the way there yet, but first we need to separate the command PlaceOrder from the query CheckOrderStatus, and this will loosen up the contract and give us the ability to optimize our business process.
NOTES: 
Event sourcing is the practice of storing a history of events rather than a static model and then calculating the current state of the model from those events. The advantages of doing this is first of all it becomes a natural audit log. We have this entire history of everything that has happened in the system, and we can rely upon this history because we’re using it in order to determine the current state. And then the second benefit of it has to do to integration. When we’re integrating with another system, we’ll usually want to send it the events that have occurred in the past.The third benefit has to do with error correction. When you have an entire history of all of the things that have occurred in your application, it’s very easy to go back and spot any sort of errors that have occurred.
